\documentclass[10pt,a4paper]{article}

\usepackage[italian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage[left=1cm,right=1cm,top=1cm,bottom=2cm]{geometry}

\usepackage{txfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\usepackage{graphicx}
\usepackage{subcaption}

\usepackage{wrapfig}

%%%%%%%% per il codice c++
\usepackage{textcomp}
\usepackage{listings}          % for creating language style
\usepackage{listingsutf8}
\input{arduinoLanguage.tex}    % adds the arduino language listing
\definecolor{commentgreen}{RGB}{2,112,10}
\definecolor{eminence}{RGB}{108,48,130}
\definecolor{weborange}{RGB}{255,165,0}
\definecolor{frenchplum}{RGB}{129,20,83}


%% Define an Arduino style fore use later %%
\lstdefinestyle{myArduino}{
  language=Arduino,
    %% Add other words needing highlighting below %%
    morekeywords=[1]{},                  % [1] -> dark green
    morekeywords=[2]{FILE_WRITE},        % [2] -> light blue
    morekeywords=[3]{SD, File},          % [3] -> bold orange
    morekeywords=[4]{open, exists, write, SoftwareSerial},      % [4] -> orange
    frame=tb,    
    inputencoding=utf8,
    extendedchars=true,
    literate={è}{{\`{e}}}{1},
    breaklines=true,  
}

\lstdefinestyle{mycpp}{
    language=C++,
    inputencoding=utf8,
    extendedchars=true,
    literate={è}{{\`{e}}}{1},
    frame=tb,
    tabsize=2,
    breaklines=true,                    % wordwrapping
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    tabsize=2,         
    basicstyle=\fontsize{9}{11}\ttfamily,
    backgroundcolor=\color{light-gray},
    xleftmargin=.25in,
    showstringspaces=false,
    numbers=left,                    
    numbersep=5pt,                   
    %numberstyle=\color{arduinoGrey},    
    %stepnumber=2, 
    %upquote=true,
    commentstyle=\color{commentgreen},
    keywordstyle=\color{eminence},
    stringstyle=\color{red},
    basicstyle=\small\ttfamily, % basic font setting
    emph={int,char,double,float,unsigned,void,bool},
    emphstyle={\color{blue}},
    escapechar=\&,
    % keyword highlighting
    classoffset=1, % starting new class
    otherkeywords={>,<,.,;,-,!,=,~},
    morekeywords={>,<,.,;,-,!,=,~},
    keywordstyle=\color{weborange},
    classoffset=0,
}
%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{siunitx} %pacchetto per le unita' di misura

%%%%%%%%%%%%%%%%%%%%%% per i flowchart
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{arrows.meta}
\tikzset{%
    >={Latex[width=2mm,length=2mm]},
      % Specifications for style of nodes:
         declare/.style = {trapezium,draw=black, minimum width=4cm, minimum height=1cm, 
                                trapezium right angle=-70, trapezium left angle=70,
                                minimum width=4cm, minimum height=1cm,
                                text centered, font=\sffamily},
           start/.style = {ellipse, draw, draw=black, minimum width=4cm, 
                                minimum height=1cm, text centered, font=\sffamily},
            cond/.style = {diamond, aspect=2, draw, draw=black,
                                minimum width=4cm, minimum height=1cm,
                                text centered, font=\sffamily},
            rect/.style = {rectangle, draw, draw=black,
                                minimum width=4cm, minimum height=1cm,
                                text centered, font=\sffamily},
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 

\pagenumbering{arabic}
\pagestyle{plain}

% per non farlo anadre a capo ovunque
\usepackage[none]{hyphenat}
% per togliere gli ident all'inizio dei paragrafi
\setlength{\parindent}{0pt}






\begin{document}

\subsection{programma per l'acquisizione dei dati dal kinect e da arduino}
Questo programma \`e stato usato per acquisire i dati dai dispositivi e scriverli in dei file di testo. Per poter lavorare meglio abbiamo separato il programma principale in diverse librerie con scopi specifici, la lista completa delle librerie usate \`e:
\begin{lstlisting}[style=mycpp, caption=librerie usate, captionpos=b]
// libreria usata da visual studio, da togliere in caso si usi un altro ide
#include "pch.h"

// librerie standard per i file stringhe e altro
#include <cstddef>
#include <cstdlib>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <ostream>
#include <string>
#include <math.h>

// librerie create da noi
#include "real_time.h"
#include "kin_file_manager.h"
#include "ard_file_manager.h"
#include "data_structure.h"

// libreria per usare i thread
#include <boost/thread.hpp>

// altre librerie per log, alcuni tipi di dato, un buffer FIFO
#include <boost/log/core.hpp>
#include <boost/call_traits.hpp>
#include <boost/circular_buffer.hpp>
#include <boost/container/vector.hpp>

// altre librerie per il logger
#include <boost/log/attributes.hpp>
#include <boost/log/attributes/scoped_attribute.hpp>
#include <boost/log/expressions.hpp>
#include <boost/log/sinks/sync_frontend.hpp>
#include <boost/log/sinks/text_ostream_backend.hpp>
#include <boost/log/sources/basic_logger.hpp>
#include <boost/log/sources/record_ostream.hpp>
#include <boost/log/sources/severity_logger.hpp>
#include <boost/log/utility/setup/common_attributes.hpp>
#include <boost/log/utility/setup/console.hpp>
#include <boost/log/utility/setup/file.hpp>

#include <boost/smart_ptr/make_shared_object.hpp>
#include <boost/smart_ptr/shared_ptr.hpp>

// altre librerie per i thread 
#include <boost/thread/condition_variable.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/thread/thread.hpp>

// librereria per il tempo
#include <boost/date_time/posix_time/posix_time.hpp>

// libreria fatta da noi per gestire la seriale
#include "Serial_handler.h"

// librerie di Windows e kinect 
#include <Windows.h>
#include <Kinect.h>
#include <Shlobj.h>

// namespace standard
using namespace std;
\end{lstlisting}
%
%
Le librerie fatte da noi sono: "real\_time.h", "kin\_file\_manager.h", "ard\_file\_manager.h", "data\_structure.h", "Serial\_handler.h". 
In "real\_time.h" ci sono alcune funzioni per prendere il tempo e misurarlo:
\begin{lstlisting}[style=mycpp, caption=librerie usate, captionpos=b]
#pragma once

#ifndef _REAL_TIME_H_
#define _REAL_TIME_H_

#include <boost/chrono.hpp>
#include <boost/timer/timer.hpp>

class real_time
{
private:
  boost::timer::cpu_timer timer;
  boost::timer::cpu_times t;

public:
  /// <summary>
  /// start the time counting
  /// </summary>
  /// <returns></returns>
  void start();

  /// <summary>
  /// return enlapsed time in millisecond
  /// </summary>
  /// <returns></returns>
  float stop();

  /// <summary>
  /// get the time in millisecond
  /// </summary>
  /// <returns></returns>
  uint64_t get_curr_time();

};

#endif // #ifndef _REAL_TIME_H_
\end{lstlisting}
%
%
In "kin\_file\_manager.h" ci sono le funzioni per gestire il file di testo relativo al kinect:
\begin{lstlisting}[style=mycpp, caption=librerie usate, captionpos=b]
#pragma once

#ifndef _KIN_FILE_MANAGER_H_
#define _KIN_FILE_MANAGER_H_

#include <iostream>
#include <ostream>
#include <fstream>
#include <string>

// in questa libreria sono dichiarate le varie strutture dati
#include "data_structure.h"

class kin_file_manager
{
private:
  std::fstream f;
  std::ios::_Openmode mode;
  unsigned long int line_id = 0;

public:
  // il costruttore provvede a settare il nome del file e la modalit\`a di apertura
  kin_file_manager(std::string file_name, std::ios::_Openmode mode);

  // questa funzione provvede a scrivere un singolo blocco di dati nel file
  void write_data_line(kinect_data dat);

  // funzione che legge un blocco di dati dal file e lo sposta nella struttura dati
  // se si \`e raggiunta la fine del file la funzione ritorna 0, altrimenti ritorna 1. 
  bool read_data_line(kinect_data* dat);

  // distruttore della classe, chiude il file
  ~kin_file_manager()
  {
  f.close();
  }

  // funzione che chiude il file
  void close()
  {
  f.close();
  }

};

#endif // #ifndef _KIN_FILE_MANAGER_H_
\end{lstlisting}
%
%
Stessa cosa per "ard\_file\_manager.h" che contiene le funzioni per la gestione del file di testo relativo ai dati di arduino:
\begin{lstlisting}[style=mycpp, caption=librerie usate, captionpos=b]
#pragma once

#ifndef _ARD_FILE_MANAGER_
#define _ARD_FILE_MANAGER_

#include <iostream>
#include <ostream>
#include <fstream>
#include <string>
#include "data_structure.h"


class ard_file_manager
{
private:
  std::fstream f;
  std::ios::_Openmode mode;
  unsigned long int line_id = 0;

public:
  ard_file_manager(std::string file_name, std::ios::_Openmode mode);

  void write_data_line(arduino_data dat);

  bool read_data_line(arduino_data* dat);

  ~ard_file_manager()
  {
    f.close();
  }

  void close()
  {
    f.close();
  }
};

#endif //#ifndef _ARD_FILE_MANAGER_
\end{lstlisting}
Questa libreria \`e strutturata in modo totalmente simile alla precedente con l'unica differenza che la struttura dati utilizzata \`e relativa ad arduino e non al kinect.
\\
%
%
La libreria "data\_structure.h" \`e fondamentale e definisce le strutture dati utilizzate nel resto del programma:
\begin{lstlisting}[style=mycpp, caption=librerie usate, captionpos=b]
#pragma once


#ifndef _DATA_STRUCTURE_H_
#define _DATA_STRUCTURE_H_

#include <iostream>
#include <string>
#include <boost/array.hpp>

////////// massiiiiiiiiiiiiiiiiii <------------------------------------------------
// struttura dati per gestire i dati provenienti dal kinect
struct kinect_data
{
  static const int number_of_joints = 3;

  // sottostruttura che contiene i dati di ogni giunto: il suo numero, il giunto attaccato ad esso, la posizione e l'angolo rispetto all'altro giunto
  struct joit_data
  {
    int joint_name = -1;
    int to_joint = -1;
    float position[3] = { 0, 0, 0 };
    float angle[3] = { 0, 0, 0 };
  };

  // <-------------------------------------------------------massiiii
  int needed_joint[number_of_joints] = { 8, 9, 10 };
  int to_joint[24] = { -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
  int to_ref_joint[24] = { -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }; // tabella di accesso (chiave numero joint kinect) -> (restituisce l-indice del numero del giunto in needed_joint)    
  float ref_Ang_x[number_of_joints] = { 0, 0, 0 }; //per  8, 9
  float ref_Ang_y[number_of_joints] = { 0, 0, 0 }; //per 8, 9
  float ref_Ang_z[number_of_joints] = { 180, 180, 0 }; //per 8, 9
  float mul_fctor_x[number_of_joints] = { 0, 0, 0 }; //per 8, 9
  float mul_fctor_y[number_of_joints] = { 1, 1, 0 }; //per 8, 9
  float mul_fctor_z[number_of_joints] = { 1, 1, 0 }; //per 8, 9

  //int needed_joint[number_of_joints] = { 4, 5, 6, 8, 9, 10, 1, 20 };
  //int to_joint[24] = { -1, 20, -1, -1, 5, 6, -1, -1, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, };
  //int to_ref_joint[24] = { -1, 6, -1, -1, -1, 1, 2, -1, 3, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1 }; // tabella di accesso (chiave numero joint kinect)  
  //float ref_Ang_x[number_of_joints] = { 0, 0, 0, 0, 0, 0, -90, 0 }; //per 4, 5, 8, 9
  //float ref_Ang_y[number_of_joints] = { 0, 0, 0, 0, 0, 0, 90, 0 }; //per 4, 5, 8, 9
  //float ref_Ang_z[number_of_joints] = { 180, 180, 0, 180, 180, 0, 270, 0 }; //per 4, 5, 8, 9
  //float mul_fctor_x[number_of_joints] = { 0, 0, 0, 0, 0, 0, 0, 0 }; //per 4, 5, 8, 9
  //float mul_fctor_y[number_of_joints] = { 1, 1, 0, 1, 1, 0, 0, 0 }; //per 4, 5, 8, 9
  //float mul_fctor_z[number_of_joints] = { 1, 1, 0, 1, 1, 0, 0, 0 }; //per 4, 5, 8, 9

  joit_data needed_joints[number_of_joints];

  // tempo esatto in cui i dati sono stati acquisiti
  uint64_t frame_time = 0;

  // questo che era? <-----------------------------------
  uint64_t contatore = 0;

  // funzione per verificare se il frame acquisito \`e parziale o completo 
  bool full_frame();

  // funzione per stampare i dati memorizzati
  void print_data();

  float jointAngleX(float *P1, float *P2);

  float jointAngleY(float *P1, float *P2);

  float jointAngleZ(float *P1, float *P2);

  void updateAngles();

  // funzione per convertire il numero del giunto in una stringa
  std::string joint_Enum_ToStr(int n, std::string language);
};

// struttura dati per gestire i dati provenienti da arduino
struct arduino_data
{
  // variabili che rappresentano i dati: dell'accelerometro, del giroscopio, del magnetometro e la temperatura
  float acc_xyz[3];
  float gy_xyz[3];
  float magn_xyz[3];
  float temp;

  // tempo esatto di acquisizione dei dati
  uint64_t frame_time = 0;

  // ?
  uint64_t contatore = 0;

  // funzione che permette di stampare il set di dati attualmente immagazzinato a schermo 
  void print_data();
};

// struttura template che gestisce un set di dati del dataset
template<typename type_in, std::size_t N, typename type_out, std::size_t M>
struct dataset_data
{
  boost::array<type_in, N> in;
  boost::array<type_out, M> out;

  // stamapa i dati attualmente immagazzinati
  void print_data();
};

#endif //#ifndef _DATA_STRUCTURE_H_
\end{lstlisting}
%
%
Infine l'ultima libreria fatta da noi ospita la classe che gestisce la seriale per la comunicazione tramite bluetooth con arduino:
\begin{lstlisting}[style=mycpp, caption=librerie usate, captionpos=b]
#pragma once

#ifndef _SERIAL_HADLER_H_
#define _SERIAL_HADLER_H_

#include <iostream>
#include <string>
#include <boost/asio.hpp> 
#include <boost/bind.hpp>
#include <boost/asio/serial_port.hpp> 


class Serial
{
private:
  boost::asio::serial_port* port;

  union Scomp_float
  {
    float n_float;
    uint32_t n_int;
    uint8_t n_bytes[4];
  };

  union Scomp_msg_tag
  {
    uint16_t n_16b;
    uint8_t n_bytes[2];
  };

public:


  Serial(std::string com);


  /// <summary>
  /// sincronizza arduino ed il pc
  /// </summary>
  void sinc();

  /// <summary>
  /// invia un floar ad arduino
  /// </summary>
  /// <param name="n"></param>
  void send_float(float n);

  /// <summary>
  /// riceve un float da arduino
  /// </summary>
  /// <returns></returns>
  float receive_float();

  void send_char(char ch);

  char receive_char();

  /// <summary>
  /// receive the data of acc, gy, magn from arduino
  /// </summary>
  /// <param name="acc_xyz"></param>
  /// <param name="g_xyz"></param>
  /// <param name="magn"></param>
  /// <param name="temp"></param>
  /// <returns>
  /// -> 0 if the trasmission is good
  /// -> 1 if it falied
  /// </returns>
  int receive_data(float* acc_xyz, float* g_xyz, float* magn, float* temp);

  ~Serial()
  {
    port->close();
  }
};

#endif // #ifndef _SERIAL_HADLER_H_
\end{lstlisting}
%
%
ora devo cominciare con il main e tutte le classi che ci stanno dentro

\end{document}