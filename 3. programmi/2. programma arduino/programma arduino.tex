\documentclass[10pt,a4paper]{article}

\usepackage[italian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage[left=1cm,right=1cm,top=1cm,bottom=2cm]{geometry}

\usepackage{txfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

%per le immagini
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{wrapfig}

%per i link
\usepackage{hyperref} 

%%%%%%%% per il codice c++
\usepackage{textcomp}
\usepackage{listings}          % for creating language style
\usepackage{listingsutf8}
\input{arduinoLanguage.tex}    % adds the arduino language listing
\definecolor{commentgreen}{RGB}{2,112,10}
\definecolor{eminence}{RGB}{108,48,130}
\definecolor{weborange}{RGB}{255,165,0}
\definecolor{frenchplum}{RGB}{129,20,83}


%% Define an Arduino style fore use later %%
\lstdefinestyle{myArduino}{
  language=Arduino,
    %% Add other words needing highlighting below %%
    morekeywords=[1]{},                  % [1] -> dark green
    morekeywords=[2]{FILE_WRITE},        % [2] -> light blue
    morekeywords=[3]{SD, File},          % [3] -> bold orange
    morekeywords=[4]{open, exists, write, SoftwareSerial},      % [4] -> orange
    frame=tb,    
    inputencoding=utf8,
    extendedchars=true,
    literate={è}{{\`{e}}}{1},
    breaklines=true,  
}

\lstdefinestyle{mycpp}{
    language=C++,
    inputencoding=utf8,
    extendedchars=true,
    literate={è}{{\`{e}}}{1},
    %escapeinside={(*******}{*******)}
    escapechar=\£,
    %escapeinside=~~,
    frame=tb,
    tabsize=2,
    mathescape=false,
    breaklines=true,                    % wordwrapping
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},         
    basicstyle=\fontsize{9}{11}\ttfamily,
    backgroundcolor=\color{light-gray},
    xleftmargin=.25in,
    showstringspaces=false,
    numbers=left,                    
    numbersep=5pt,                   
    %numberstyle=\color{arduinoGrey},    
    %stepnumber=2, 
    %upquote=true,
    commentstyle=\color{commentgreen},
    keywordstyle=\color{eminence},
    stringstyle=\color{red},
    basicstyle=\small\ttfamily, % basic font setting
    emph={int,char,double,float,unsigned,void,bool},
    emphstyle={\color{blue}},
    % keyword highlighting
    classoffset=1, % starting new class
    otherkeywords={>,<,.,;,-,!,=,~},
    morekeywords={>,<,.,;,-,!,=,~},
    keywordstyle=\color{weborange},
    classoffset=0,
}


\lstdefinestyle{myoutput}
{
    inputencoding=utf8,
    extendedchars=true,
    literate={è}{{\`{e}}}{1},
    tabsize=2,
    frame=tb,
    breaklines=true,                    % wordwrapping
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},         
    basicstyle=\fontsize{9}{11}\ttfamily,
    backgroundcolor=\color{light-gray},
    xleftmargin=.25in,
    showstringspaces=false,
    numbers=left,                    
    numbersep=5pt, 
}
%%%%%%%%%%%%%%%%%%%%%%%


\usepackage{siunitx} %pacchetto per le unita' di misura

%%%%%%%%%%%%%%%%%%%%%% per i flowchart
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes.geometric}
\usepgflibrary{shapes.symbols}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{decorations.pathreplacing}

\tikzset{%
  >={Latex[width=2mm,length=2mm]},
  % Specifications for style of nodes:
            rect/.style = {rectangle, rounded corners, draw=black,
                           minimum width=4cm, minimum height=1cm,
                           text centered, font=\sffamily},
           round/.style = {ellipse, draw, draw=black,
                           minimum width=4cm, minimum height=1cm,
                           text centered, font=\sffamily},
       smallrect/.style = {rectangle, rounded corners, draw=black,
                           minimum width=2cm, minimum height=1cm,
                           text centered, font=\sffamily},
 smallrectsplit4/.style = {rectangle split, rectangle split parts=4, 
	                       rectangle split part fill={green!30, none, none, none},
	                       align=center,
	                       rounded corners, draw=black,
                           minimum width=2cm, minimum height=1cm,
                           text centered, font=\sffamily},
        rectpile/.style = {rectangle, outer sep=0pt, align=right,
                           minimum width=1cm, minimum height=0.5cm, font=\sffamily}
}

%\tikzset{%
%    >={Latex[width=2mm,length=2mm]},
%      % Specifications for style of nodes:
%         declare/.style = {trapezium,draw=black, minimum width=4cm, minimum height=1cm, 
%                                trapezium right angle=-70, trapezium left angle=70,
%                                minimum width=4cm, minimum height=1cm,
%                                text centered, font=\sffamily},
%           start/.style = {ellipse, draw, draw=black, minimum width=4cm, 
%                                minimum height=1cm, text centered, font=\sffamily},
%            cond/.style = {diamond, aspect=2, draw, draw=black,
%                                minimum width=4cm, minimum height=1cm,
%                                text centered, font=\sffamily},
%            rect/.style = {rectangle, draw, draw=black,
%                                minimum width=4cm, minimum height=1cm,
%                                text centered, font=\sffamily},
%}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 

\pagenumbering{arabic}
\pagestyle{plain}

% per non farlo anadre a capo ovunque 
% va in conflitto con quello che lo fa andare a capo nel codice quindi attenzione <--------
%\usepackage[none]{hyphenat}
\usepackage[italian=nohyphenation,english=nohyphenation]{hyphsubst}

% per togliere gli ident all'inizio dei paragrafi
\setlength{\parindent}{0pt}






\begin{document}

\subsection{Programma arduino}
Questo programma si occupa di acquisire i dati dai sensori attraverso l'I2C, elaborarli e scriverli sulla seriale, in modo che il modulo bluetooth li invii al pc. Il programma si scompone nella classe "MPU0\_6050" che gestisce l'accelerometro, nella classe "QMC5883" che gestisce il magnetometro, nella classe "serial" per gestire la seriale e nelle 2 funzioni standard di arduino "setup" e "loop". Inoltre abbiamo usato la libreria "Wire.h" per l'I2C. \\
Nel "setup" si trova soltanto l'inilizializzazione alla seriale per comunicare con il modulo "HC-05", il baud rate impostato \`e lo stesso che \`e stato settato nel modulo tramite la modalit\`a AT:
\begin{lstlisting}[style=myArduino, caption=funzione "setup", captionpos=b]
void setup() 
{
  Serial.begin(115200);
}
\end{lstlisting}
Nella funzione "loop" si trovano le varie dichiarazioni alle altre classi, un while per aspettare che il modulo "HC-05" sia connesso al pc ed il ciclo infinito che provvede ad acquisire i dati dai sensori e scriverli sulla seriale:
\begin{lstlisting}[style=myArduino, caption=funzione "loop", captionpos=b]
void loop() 
{
  // chiamo i costruttori delle 2 classi che gestiscono i sensori e provvedo al loro settaggio.
  QMC5883 mm;
  MPU_6050 aa;
  aa.setting();

  // accendo un led per il debug  
  digitalWrite(13, HIGH);
  
  // aspetto finchè il pin "state" del modulo "HC-05" non diventa alto
  while (!digitalRead(3))
  {
    delay(10);
  }
  
  // quando il bluetooth è connesso posso procedere ad inizializzare e sincronizzare la seriale
  serial ser; 
  ser.sinc(); 

  // spengo il led
  digitalWrite(13, LOW);
  
  while (true)
  {
    // acquisisco i dati del magnetometro e li normalizzo
    mm.get_data();
    mm.normalize(100);
    
    // acquisisco i dati dell'accelerometro
    aa.get_data();

    // li sposto in degli array
    float acc_xyz[] = {aa.get_AcX(), aa.get_AcY(), aa.get_AcZ()};
    float g_xyz[] = {aa.get_GyX(), aa.get_GyY(), aa.get_GyZ()};
    float magn[] = {mm.getX(), mm.getY(), mm.getZ()};

    // li scrivo sulla seriale in modo che il modulo bluetooth li trasmetta al pc.
    ser.send_data(acc_xyz, g_xyz, magn, aa.get_temp());
  }
}
\end{lstlisting}
Qui sono state usate le classi "MPU\_6050", "QMC5883" e "serial" (TODO da rifare la frase).



Le classi "MPU\_6050" e "QMC5883" si occupano di impostare i registri dei 2 moduli ed inoltre hanno metodi che permettono l'estrazione delle misurazioni da loro effettuate. 

L'impostazione dei moduli \`e stata eseguita seguendo i rispettivi datasheet e (TODO!) copiando spudoratamente esempi su internet. 
\begin{lstlisting}[style=myArduino, caption=classe "MPU\_6050", captionpos=b]
class MPU_6050
{
  public:
    int16_t AcX,AcY,AcZ,Tmp,GyX,GyY,GyZ;
    float normalized_AcX, normalized_AcY, normalized_AcZ, normalized_GyX, normalized_GyY, normalized_GyZ;
    float rescaled_AcX, rescaled_AcY, rescaled_AcZ, rescaled_GyX, rescaled_GyY, rescaled_GyZ;
  
    const uint8_t MPU = 0x68; // I2C address of the MPU-6050
    
    // costruttore della classe, accende l'MPU_6050
    MPU_6050(){...}
  
    // prede i dati dall'MPU_6050 e le sposta sulle variabili di classe.
    void get_data(){...}
  
    // funzioni per ritornare i valori dell'accelerometro
    float get_AcX(){ return (AcX*1.0); }
    float get_AcY(){...}
    float get_AcZ(){...}
  
    // funzioni per ritornare i valori del giroscopio
    float get_GyX(){ return (GyX*1.0); }
    float get_GyY(){...}
    float get_GyZ(){...}
    
    // funzioni per ritornare i valori normalizzati dell'accelerometro
    float get_normalized_AcX(){ return normalized_AcX; }
    float get_normalized_AcY(){...}
    float get_normalized_AcZ(){...}
  
    // funzioni per ritornar i valori normalizzati del giroscopio
    float get_normalized_GyX(){ return normalized_GyX; }
    float get_normalized_GyY(){...}
    float get_normalized_GyZ(){...}
  
    // funzioni per calcolare e ritornare la norma dell'accelerometro o del magnetometro
    float norma(float x, float y, float z){...}
    float get_norma_Gy(){ return norma(GyX, GyY, GyZ); }
    float get_norma_Ac(){...}
  
    // funzione per ritornare la temperatura
    float get_temp(){ return Tmp; }
  
    // funzioni per normalizzare l'accelerometro o il magnetometro
    void normalize_Ac(int Max){...}
    void normalize_Gy(int Max){...}
    
    // funzione che scrive le impostazioni all'MPU_6050
    void setting(){...}
};
\end{lstlisting}
TODO che ci metto qua in mezzo? :(
\begin{lstlisting}[style=myArduino, caption=classe "QMC5883", captionpos=b]
class QMC5883
{
  public:
    uint8_t add = 0x0D;
    int nowX = 0;
    int nowY = 0;
    int nowZ = 0;
    float rescaled_x = 0; 
    float rescaled_y = 0;
    float rescaled_z = 0;
    
    // il costruttore provvede ad inizializzare il modulo e settarne i vari registri 
    QMC5883(){...}
    
    // funzioni per ritornare i valori x-y-z del magnetometro
    float getX(){ return (nowX*1.0); }
    float getY(){...}
    float getZ(){...}

    // funzioni per ritornare i valori del magnetometro dopo averli riscalati
    float getX_rescaled(){ return rescaled_x; }
    float getY_rescaled(){...}
    float getZ_rescaled(){...}
  
    // funzione che provvede a leggere i regisrti del modulo per acquisire i dati
    // spostandoli nelle variabili di classe
    void get_data(){...}

    // funzioni per calcolare la norma e ritornare i valori normalizzati 
    float norma(float x, float y, float z){...}
    float get_norma(){ return norma(nowX, nowY, nowZ); }
    void normalize(int Max){...}
};
\end{lstlisting}
%
%
Infine la classe serial si occupa di scomporre i dati di tipo float restituiti dai moduli in array di 4 byte che poi vengono trasmessi al modulo bluetooth tramite la seriale.
\begin{lstlisting}[style=myArduino, caption=classe "serial", captionpos=b]
class serial
{
  public:

    // funzione che permette di sincronizzarsi con il pc
    void sinc(){...}

    // union per poter scompattare un float in 4 byte
    union Scomp_float{...};

    // funzione che permette di inviare un intero float scompattandolo in 
    // 4 byte che vengono trasmessi serialmente
    void send_float(float n){...}

    // funzione che permette di riceve un float come sopra
    float receive_float(){...}

    // funzione per l'invio di un solo carattere
    void send_char(char ch){...}

    // funzione per la ricezione di un singolo carattere
    char receive_char(){...}

    // funzione che provvede ad inviare i dati necessari.
    void send_data(float* acc_xyz, float* g_xyz, float* magn, float temp){...} 
};
\end{lstlisting}
Per effettuare l'operazione di serializaziopne dei float in array di byte abbiamo fatto ricorso all'uso di una struttura dati chiamata "union":
\begin{lstlisting}[style=myArduino, caption=classe "serial", captionpos=b]
union Scomp_float
{
  float f;
  int i;
  unsigned char byte_s[4];
};
\end{lstlisting}
Questa struttura dati ha la particolarit\`a che a differenza di una struct, in cui i dati sono memorizzati in modo contiguo nella memoria, l'union memorizza tutti i dati della struttura nelle stesse locazioni di memoria.
\\ \\ \\ \\ 

TODO sistemare la formattazione alla fine

\newsavebox{\mylistingboxstruct}
\newsavebox{\mylistingboxunion}

\newsavebox{\mytikzboxonestruct}
\newsavebox{\mytikzboxtwounion}

\begin{figure}[h]
	\centering
	\begin{lrbox}{\mylistingboxstruct}%
		\begin{minipage}{.30\linewidth}%
			\centering
			\begin{lstlisting}[style=mycpp]
struct es_struct
{
  int a;
  unsigned char b[4];
}
			\end{lstlisting}%
		\end{minipage}%
	\end{lrbox}%
	
	
	\begin{lrbox}{\mylistingboxunion}%
		\begin{minipage}{.30\linewidth}%
			\centering
			\begin{lstlisting}[style=mycpp]
union es_union
{
  int a;
  unsigned char b[4];
}
			\end{lstlisting}%
		\end{minipage}%
	\end{lrbox}%
	
	\begin{lrbox}{\mytikzboxonestruct}%
		\begin{minipage}{.50\linewidth}%
			\centering
			\hspace{-1cm}
			\begin{tikzpicture}[every node/.style={rectpile}]
			\node at (0, 0) (A) {0x00};
	        \node [anchor=north] at (A.south) (B) {0x01};
	        \node [anchor=north] at (B.south) (C) {0x02};
	        \node [anchor=north] at (C.south) (D) {0x03};
	        \node [anchor=north] at (D.south) (E) {0x04};
	        \node [anchor=north] at (E.south) (F) {0x05};
	        \node [anchor=north] at (F.south) (G) {0x06};
	        \node [anchor=north] at (G.south) (H) {0x07};
	        
	        \node [anchor=west, draw=black] at (A.east) (M) {};
	        \node [anchor=west, draw=black] at (B.east) (N) {};
	        \node [anchor=west, draw=black] at (C.east) (O) {};
	        \node [anchor=west, draw=black] at (D.east) (P) {};
	        \node [anchor=west, draw=black] at (E.east) (Q) {};
	        \node [anchor=west, draw=black] at (F.east) (R) {};
	        \node [anchor=west, draw=black] at (G.east) (S) {};
	        \node [anchor=west, draw=black] at (H.east) (T) {};
	        
	        \draw [decorate,decoration={brace,amplitude=10pt,raise=0pt},
	            yshift=-0pt,xshift=-0.5cm]
                (2cm,0.25cm) -- (2cm, -1.75cm) node [black,midway,xshift=0.8cm] {\hspace{-8pt}a};
            \draw [decorate,decoration={brace,amplitude=10pt,raise=0pt},
	            yshift=-0pt,xshift=-0.5cm]
                (2cm,-1.75cm) -- (2cm, -3.75) node [black,midway,xshift=0.8cm] {b[ ]};
			\end{tikzpicture}%
		\end{minipage}%
	\end{lrbox}%
	
	
	\begin{lrbox}{\mytikzboxtwounion}%
		\begin{minipage}{.50\linewidth}%
			\centering
			\begin{tikzpicture}[every node/.style={rectpile}]
			\node at (0, 0) (A) {0x00};
	        \node [anchor=north] at (A.south) (B) {0x01};
	        \node [anchor=north] at (B.south) (C) {0x02};
	        \node [anchor=north] at (C.south) (D) {0x03};
	        \node [anchor=north] at (D.south) (E) {0x04};
	        \node [anchor=north] at (E.south) (F) {0x05};
	        \node [anchor=north] at (F.south) (G) {0x06};
	        \node [anchor=north] at (G.south) (H) {0x07};
	        
	        \node [anchor=west, draw=black] at (A.east) (M) {};
	        \node [anchor=west, draw=black] at (B.east) (N) {};
	        \node [anchor=west, draw=black] at (C.east) (O) {};
	        \node [anchor=west, draw=black] at (D.east) (P) {};
	        \node [anchor=west, draw=black] at (E.east) (Q) {};
	        \node [anchor=west, draw=black] at (F.east) (R) {};
	        \node [anchor=west, draw=black] at (G.east) (S) {};
	        \node [anchor=west, draw=black] at (H.east) (T) {};
	        
	        \node [draw=black] at (3, 0) (M1) {};
	        \node [anchor=north, draw=black] at (M1.south) (N1) {};
	        \node [anchor=north, draw=black] at (N1.south) (O1) {};
	        \node [anchor=north, draw=black] at (O1.south) (P1) {};
	        \node [anchor=north, draw=black] at (P1.south) (Q1) {};
	        \node [anchor=north, draw=black] at (Q1.south) (R1) {};
	        \node [anchor=north, draw=black] at (R1.south) (S1) {};
	        \node [anchor=north, draw=black] at (S1.south) (T1) {};
	        
	        \draw [decorate,decoration={brace,amplitude=10pt,raise=0pt},
	            yshift=-0pt,xshift=-0.5cm]
                (2cm,0.25cm) -- (2cm, -1.75cm) node [black,midway,xshift=0.8cm] 
                {\hspace{-10pt}a};
            \draw [decorate,decoration={brace,amplitude=10pt,raise=0pt},
	            yshift=-0pt,xshift=-0.5cm]
                (4cm,0.25cm) -- (4cm, -1.75) node [black,midway,xshift=0.8cm] {b[ ]};

            \draw [densely dotted] (1.5,0.25) -- (3,0.25);              
            
            \draw [densely dotted] (1.5,-1.75) -- (3,-1.75);       
            
			\end{tikzpicture}%
		\end{minipage}%
	\end{lrbox}%
	
	\begin{tabular}{@{}cc@{}}
		%
		\begin{tabular}{@{}c@{}}
		
			\begin{subfigure}[b]{.40\textwidth}
				\centering
				\usebox{\mylistingboxstruct}
				\vspace{-10pt}
				\caption{Struct generico}
	  			\label{fig:es_struct}
	  			\vspace{10pt}
	 		\end{subfigure} \\
	 		
	 		\begin{subfigure}[b]{.45\textwidth}
				\centering
				\usebox{\mytikzboxonestruct}
				\vspace{0pt}
				\caption{Rappresentazione dei dati dello struct\\memorizzati in ram}
	  			\label{fig:struct_ram}
	  			\vspace{0pt}
	 		\end{subfigure}  
			%
			
		\end{tabular}

		\hspace{-50pt}		
		
		\begin{tabular}{@{}c@{}}
			
			\begin{subfigure}[b]{.40\textwidth}
				\centering
				\usebox{\mylistingboxunion}
				\vspace{-10pt}
				\caption{Union generico}
	  			\label{fig:struct_ram}
	  			\vspace{10pt}
	 		\end{subfigure} \\
			
			
			\begin{subfigure}[b]{.45\textwidth}
				\centering
				\usebox{\mytikzboxtwounion}
				\vspace{0pt}
				\caption{Rappresentazione dei dati dell'union\\memorizzati in ram}
	  			\label{fig:es_union}
	  			\vspace{0pt}
	 		\end{subfigure} 
	 		
		\end{tabular}
		
	\end{tabular}
	
	\caption{Confronto tra struct ed union}
	\label{fig:struct_union}
\end{figure}
Come si pu\`o vedere dalla figura \ref{fig:struct_union} lo struct (figura \ref{fig:es_struct}) memorizza i dati in ram facendo partire l'intero dall'indirizzo 0x00 e l'array di byte dall'indirizzo 0x04 (figura \ref{fig:struct_ram}), mentre l'union (figura \ref{fig:es_union}) sovrappone i 2 dati nelle stesse locazioni di memoria (figura \ref{fig:struct_union}).
Cio\`o permmette ad esempio di leggere un intero (o un qualunque altro tipo di dato) come un insieme di byte: con riferimento alla figura \ref{fig:es_union} se pongo:
\begin{lstlisting}[style=myArduino, caption=classe "serial", captionpos=b, label={lst:es_union}]
es_union U;
U.a = 0x0514FFAA;
\end{lstlisting}
e successivamente vado a vedere il valore di b[ ] ottengo i valori:
\begin{lstlisting}[style=myoutput, caption=classe "serial", captionpos=b, label={lst:es_union}]
U.b[0] -> 0x05
U.b[1] -> 0x14
U.b[2] -> 0xFF
U.b[3] -> 0xAA
\end{lstlisting}
che sono esattamente i byte costituenti U.a. Ci\`o ci ha permesso di inviare un float come sequenza di byte al pc, nella classe serial sul pc (TODO inserire ref) c'e` esattamente lo stesso tipo di struttura per ricostruire il float. 






\end{document}